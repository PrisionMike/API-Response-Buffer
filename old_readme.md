# Learning Project - Working with APIs, Concurrency and Actix

This project is to help new Rustaceans get familiar with creating and API that works with concurrency and create a web interface to the local API
with Actix.

<!-- More info required on how local APIs are made and how they work -->

# Behaviour Driven Development of Concurrency w/ API Calls

Web based APIs are slow. In order to fix this problem, we will use
Rust to make concurrent API calls and cache them so that they are
available to the system on demand without waiting.

In order to develop this, we will make API calls to a random number
generator which take approximately 1 second per call and fill a queue
of random numbers that will be consumed by our program. We will keep
the queue of random numbers full by making concurrent calls to the API.

# How To Participate

Familiarize yourself with the code and check out the [DevBoard](https://github.com/PrisionMike/API-Response-Buffer/projects/1) under the Projects link to
see the proposed next steps for code development.

# End to End Description

### INPUT:

    jhaadi {api-request} [Number of responses to store]

### OUTPUT:

    __________________*************___________________
    Local API created successfully!\
    New API name:   amirkhan\
    Fetch command:  amirkhan.get_response(N)
    Fetch output:   O1,O2,O3
    Status check command:
                    amirkhan.get_status
    Status check response:
                    Available responses in cache: {N}
                    Last Request at: {Date - Time}
    Cache level:    amirkhan.get_lev_check  (Available responses in Cache)
    Stale check command:
                    amirkhan.stalecheck (Last Request at)
    Flush command:  amirkhan.flush
    Refill command: amirkhan.refill(N)
    ________________**************___________________

# Modules

**[clap](https://docs.rs/clap/latest/clap/)** -- command line argument parser

**[actix](https://actix.rs/)** -- fast web framework for Rust

**[std::net](https://doc.rust-lang.org/std/net/index.html)** -- Networking primitives for TCP/UDP communication.

**[async/await](https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html)** -- a primer on Rust's built-in tool for writing asynchronous functions that look like synchronous code.

## M1: Initiator

The command line tool uses 2 arguments: **the API request text** and the
**number of responses = N** to cache.
Upon being turned on, it creates a **Tank** of size _N_. This tank is a queue of random numbers generated by the API. It will automatically refill itself.

It runs as a background process for the loading and maintenance of the _Tanks_.

When the _Initiator_ receives a `Ready` signal from the tank, it needs to create a **Tap**, or concurrent calls to the API.

The **Tap** will be instantiated by the **Tank** instance and 2 available port numbers
for sending the request and receiving the response respectively.

## M2: Tank

FIFO buffer. It is filled with _N_ `None` values which are replaced by values from the API.

### Recharge process

The program then makes _N_ API requests and pushes the response of each request
to the Q-tank as `Some(Response)`. [ loop (request and push) N times]
Upon the successfull filling of the tank, the tank will save the current date and time with itself by the name
`Last Response Time Stamp`. After that, the _Tank_ will signal the initiator that it is `ready` to be
fitted with a tap (Converted into a local API where the values can be consumed by the program).

It can also receive a `Recharge` command, upon which it initiates the _Recharge process_.

On receiving a `Flush` command, the queue will be cleared. (Filled with `None`)

On receiving a `Level Check` request, it will return the number of currently available responses.

On receiving a `get Capacity` command, it will return its capacity.

On receiving a `Stale check` command, it will return the `Last Response Time Stamp`.

## M2: The fetch-from-tank API (Tap) [Local API]

A Tap is provided to a **Tank** for retrieval of the stored data along with 2 port addresses
to receive response and send response requests.

When a user asks the Tap to draw _M_ amount of data from the tap, the tap
will create a _Glass_ of capacity _M_ and place it underneath it.
The tap will then pull _M_ amount of data sequentially from the tank.
The tap will stop filling the glass after either:

1. _M_ responses are pushed onto the tank.
2. A `None` is pushed in the tank.

The tap will then check the tank level.  
If the level of the tank is less than 1/3rd of its capacity, the
tap will request a refill.

## M3: Outpour

Given a _Glass_ from the Tap, it will format the content of the glass
using the delimiter (comma+CRLF), and send it to `stdout`. -->
